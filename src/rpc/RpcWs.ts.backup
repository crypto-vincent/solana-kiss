/*
import { JsonArray, JsonObject, JsonValue } from "../data/Json";
import { RxObservable } from "../data/Rx";

export type RpcWs = (
  method: string,
  params: JsonArray,
  config: JsonObject | undefined,
) => RxObservable<JsonValue>;

export function rpcWsFromUrl(
  url: string,
  options?: {
    commitment?: "confirmed" | "finalized";
    redundantSubscriptions?: number;
  },
): RpcWs {
  const connections = new Array<{
    websocket: WebSocket;
    subscriptionIds: Map<string, number>;
  }>();
  for (let i = 0; i < (options?.redundantSubscriptions ?? 1); i++) {
    connections.push({
      websocket: new WebSocket(url),
      subscriptionIds: new Map(),
    });
  }

  const lookupListeners = new Map<string, RxListener<JsonValue>>();

  const lookupObservables = new Map<string, RxObservable<JsonValue>>();
  // TODO - handle proper reconnection mechanisms

  return (method, params, config) => {
    if (config !== undefined) {
      const contextCommitment = options?.commitment;
      if (contextCommitment !== undefined) {
        config = {
          preflightCommitment: contextCommitment,
          commitment: contextCommitment,
          ...config,
        };
      }
      params.push(config);
    }

    const lookupKey = JSON.stringify([method, params]);

    const lookupObservable = lookupObservables.get(lookupKey);
    if (lookupObservable) {
      return lookupObservable;
    }

    return rxObervableEffect((listener) => {
      lookupListeners.set(lookupKey, listener);
      return () => {};
    });

    const message = JSON.stringify({
      jsonrpc: "2.0",
      id: uniqueId++,
      method,
      params,
    });

    return {
      subscribe: (_listener: (value: JsonValue) => void) => {
        return () => {};
      },
    };
  };
}

export class RpcWsConnection {
  readonly #websocket: WebSocket;
  readonly #messageQueue: Array<string>;

  readonly listenerByLookupKey: Map<number, RxListener<JsonValue>>;
  readonly lookupKeyByRequestId: Map<number, number>;
  readonly lookupKeyBySubscriptionId: Map<number, number>;

  constructor(url: string) {
    this.#websocket = new WebSocket(url);
    this.#messageQueue = new Array();

    this.listenerByLookupKey = new Map();
    this.lookupKeyByRequestId = new Map();
    this.lookupKeyBySubscriptionId = new Map();

    this.#websocket.on("open", () => {
      this.#flushMessages();
    });
    this.#websocket.on("message", (data: any) => {
      try {
        const messageJson = JSON.parse(data.toString());
        const messageValue = messageJsonDecoder(messageJson);

        if (messageValue.subscribed) {
          const lookupKey = this.lookupKeyByRequestId.get(
            messageValue.subscribed.subscriptionId,
          );
          if (lookupKey === undefined) {
            throw new Error(``); // TODO - error message
          }
          this.lookupKeyBySubscriptionId.set(
            messageValue.subscribed.subscriptionId,
            lookupKey,
          );
        }

        if (messageValue.unsubscribed) {
        }

        if (messageValue.notification) {
          const lookupKey = this.lookupKeyBySubscriptionId.get(
            messageValue.notification.subscriptionId,
          );
          if (lookupKey === undefined) {
            throw new Error(``); // TODO - error message
          }
          const listener = this.listenerByLookupKey.get(lookupKey);
          if (listener === undefined) {
            throw new Error(``); // TODO - error message
          }
          listener(messageValue.notification.payload);
        }
      } catch (error) {
        console.warn("Invalid WebSocket message:", error);
      }
    });
  }

  subscribeTo(
    method: string,
    params: JsonArray,
    listener: RxListener<JsonValue>,
  ) {
    const lookupKey = uniqueId++;
    const requestId = uniqueId++;
    this.listenerByLookupKey.set(lookupKey, listener);
    this.lookupKeyByRequestId.set(requestId, lookupKey);
    this.#messageQueue.unshift(
      JSON.stringify({
        jsonrpc: "2.0",
        id: requestId,
        method: `${method}Subscribe`,
        params,
      }),
    );
    this.#flushMessages();
    return () => {
      this.listenerByLookupKey.delete(lookupKey);
      const subscriptionId = 42; // TODO - proper lookup
      this.#messageQueue.unshift(
        JSON.stringify({
          jsonrpc: "2.0",
          id: uniqueId++,
          method: `${method}Unsubscribe`,
          params: [subscriptionId],
        }),
      );
      this.#flushMessages();
    };
  }

  #flushMessages() {
    if (this.#websocket.readyState !== WebSocket.OPEN) {
      return;
    }
    while (true) {
      const request = this.#messageQueue.shift();
      if (request !== undefined) {
        this.#websocket.send(request);
      } else {
        return;
      }
    }
  }
}

function extract<K, V>(map: Map<K, V>, key: K) {
  const value = map.get(key);
  if (value === undefined) {
    throw new Error(`RpcWs: Missing map value for key: ${key}`);
  }
  map.delete(key);
  return value;
}

const messageJsonDecoder = jsonDecoderTrySequentially<
  OneKeyOf<{
    subscribed: { requestId: number; subscriptionId: number };
    notification: { subscriptionId: number; payload: JsonValue };
    unsubscribed: { requestId: number };
  }>
>([
  jsonDecoderWrapped(
    jsonDecoderObjectToObject({
      jsonrpc: jsonDecoderConst("2.0"),
      id: jsonCodecNumber.decoder,
      result: jsonCodecNumber.decoder,
    }),
    (message) => ({
      subscribed: {
        requestId: message.id,
        subscriptionId: message.result,
      },
    }),
  ),
  jsonDecoderWrapped(
    jsonDecoderObjectToObject({
      jsonrpc: jsonDecoderConst("2.0"),
      method: jsonCodecString.decoder,
      params: jsonDecoderObjectToObject({
        result: jsonCodecValue.decoder,
        subscription: jsonCodecNumber.decoder,
      }),
    }),
    (message) => ({
      notification: {
        subscriptionId: message.params.subscription,
        payload: message.params.result,
      },
    }),
  ),
  jsonDecoderWrapped(
    jsonDecoderObjectToObject({
      jsonrpc: jsonDecoderConst("2.0"),
      id: jsonCodecNumber.decoder,
      result: jsonDecoderConst(true),
    }),
    (message) => ({
      unsubscribed: {
        requestId: message.id,
      },
    }),
  ),
]);

let uniqueId = 1;
  */
