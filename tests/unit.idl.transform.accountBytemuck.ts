import { expect, it } from "@jest/globals";
import { pubkeyFromBytes, pubkeyToBase58 } from "../src";
import { idlAccountDecode, idlAccountEncode } from "../src/idl/IdlAccount";
import { idlProgramParse } from "../src/idl/IdlProgram";

it("run", () => {
  // Create an IDL on the fly
  const programIdl = idlProgramParse({
    accounts: {
      BytemuckAccount: {
        discriminator: [],
        type: "BytemuckContainer",
      },
    },
    types: {
      BytemuckContainer: {
        serialization: "bytemuck",
        repr: "c",
        fields: [
          { name: "bytemuck_struct_c", type: "BytemuckStructC" },
          { name: "bytemuck_enum_c", type: "BytemuckEnumC" },
          { name: "bytemuck_enum_u8", type: "BytemuckEnumU8" },
          { name: "bytemuck_discriminant_c", type: "BytemuckDiscriminantC" },
          { name: "bytemuck_discriminant_u8", type: "BytemuckDiscriminantU8" },
          { name: "bytemuck_never", variants: [] },
          { name: "bytemuck_field", type: "u8" },
        ],
      },
      BytemuckStructC: {
        repr: "c",
        fields: [
          { name: "field1", type: "u16" },
          { name: "field2", type: "pubkey" },
          { name: "field3", type: "u64" },
          { name: "field4", type: "u8" },
          { name: "field5", fields: ["u8", "u32"] },
        ],
      },
      BytemuckEnumC: {
        repr: "c",
        variants: [
          { name: "Case0", fields: [] },
          { name: "Case1", fields: ["u16"] },
          { name: "Case2", fields: ["pubkey"] },
          { name: "Case3", fields: ["u64"] },
          { name: "Case4", fields: ["u8"] },
          { name: "Case5", fields: ["u32"] },
        ],
      },
      BytemuckEnumU8: {
        repr: "rust",
        variants: [
          { name: "Case0", fields: [] },
          { name: "Case1", fields: ["u16"] },
          { name: "Case2", fields: ["pubkey"] },
          { name: "Case3", fields: ["u64"] },
          { name: "Case4", fields: ["u8"] },
          { name: "Case5", fields: ["u32"] },
        ],
      },
      BytemuckDiscriminantC: {
        repr: "c",
        variants: [
          { name: "CaseA", fields: [] },
          { name: "CaseB", fields: [] },
          { name: "CaseC", fields: [] },
        ],
      },
      BytemuckDiscriminantU8: {
        repr: "rust",
        variants: [
          { name: "CaseA", fields: [] },
          { name: "CaseB", fields: [] },
          { name: "CaseC", fields: [] },
        ],
      },
    },
  });
  // Choose the instruction
  const accountIdl = programIdl.accounts.get("BytemuckAccount")!;
  // Bytemuck constants
  const keyF2 = pubkeyToBase58(
    pubkeyFromBytes(
      new Uint8Array([
        0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
        0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
        0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
      ]),
    ),
  );
  const keyC2 = pubkeyToBase58(
    pubkeyFromBytes(
      new Uint8Array([
        0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2,
        0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2,
        0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2,
      ]),
    ),
  );
  // Define dummy JSON data
  const bytemuckStructC = {
    field1: 0xf1f1,
    field2: keyF2,
    field3: 0xf3f3f3f3f3f3f3f3n.toString(),
    field4: 0xf4,
    field5: [0xf5, 0xf5f5f5f5],
  };
  // Generate cases datas
  const cases = [
    {
      name: "Case0",
      data: new Uint8Array([
        0xf1, 0xf1, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
        0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
        0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3,
        0xf4, 0xaa, 0xaa, 0xaa, 0xf5, 0xaa, 0xaa, 0xaa, 0xf5, 0xf5, 0xf5, 0xf5,
        0xaa, 0xaa, 0xaa, 0xaa, 0x00, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x00, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0x00, 0xaa, 0xaa, 0xaa, 0x00, 0xd0, 0xaa, 0xaa,
      ]),
      state: {
        bytemuck_struct_c: bytemuckStructC,
        bytemuck_enum_c: "Case0",
        bytemuck_enum_u8: "Case0",
        bytemuck_discriminant_c: "CaseA",
        bytemuck_discriminant_u8: "CaseA",
        bytemuck_never: null,
        bytemuck_field: 0xd0,
      },
    },
    {
      name: "Case1",
      data: new Uint8Array([
        0xf1, 0xf1, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
        0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
        0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3,
        0xf4, 0xaa, 0xaa, 0xaa, 0xf5, 0xaa, 0xaa, 0xaa, 0xf5, 0xf5, 0xf5, 0xf5,
        0xaa, 0xaa, 0xaa, 0xaa, 0x01, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xc1, 0xc1, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x01, 0xaa, 0xc1, 0xc1,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0x01, 0xaa, 0xaa, 0xaa, 0x01, 0xd1, 0xaa, 0xaa,
      ]),
      state: {
        bytemuck_struct_c: bytemuckStructC,
        bytemuck_enum_c: { Case1: [0xc1c1] },
        bytemuck_enum_u8: { Case1: [0xc1c1] },
        bytemuck_discriminant_c: "CaseB",
        bytemuck_discriminant_u8: "CaseB",
        bytemuck_never: null,
        bytemuck_field: 0xd1,
      },
    },
    {
      name: "Case2",
      data: new Uint8Array([
        0xf1, 0xf1, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
        0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
        0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3,
        0xf4, 0xaa, 0xaa, 0xaa, 0xf5, 0xaa, 0xaa, 0xaa, 0xf5, 0xf5, 0xf5, 0xf5,
        0xaa, 0xaa, 0xaa, 0xaa, 0x02, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2,
        0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2,
        0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0x02, 0xc2, 0xc2, 0xc2,
        0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2,
        0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2,
        0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0x02, 0xaa, 0xaa, 0xaa, 0x02, 0xd2, 0xaa, 0xaa,
      ]),
      state: {
        bytemuck_struct_c: bytemuckStructC,
        bytemuck_enum_c: { Case2: [keyC2] },
        bytemuck_enum_u8: { Case2: [keyC2] },
        bytemuck_discriminant_c: "CaseC",
        bytemuck_discriminant_u8: "CaseC",
        bytemuck_never: null,
        bytemuck_field: 0xd2,
      },
    },
    {
      name: "Case3",
      data: new Uint8Array([
        0xf1, 0xf1, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
        0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
        0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3,
        0xf4, 0xaa, 0xaa, 0xaa, 0xf5, 0xaa, 0xaa, 0xaa, 0xf5, 0xf5, 0xf5, 0xf5,
        0xaa, 0xaa, 0xaa, 0xaa, 0x03, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x03, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0x00, 0xaa, 0xaa, 0xaa, 0x00, 0xd3, 0xaa, 0xaa,
      ]),
      state: {
        bytemuck_struct_c: bytemuckStructC,
        bytemuck_enum_c: { Case3: [0xc3c3c3c3c3c3c3c3n.toString()] },
        bytemuck_enum_u8: { Case3: [0xc3c3c3c3c3c3c3c3n.toString()] },
        bytemuck_discriminant_c: "CaseA",
        bytemuck_discriminant_u8: "CaseA",
        bytemuck_never: null,
        bytemuck_field: 0xd3,
      },
    },
    {
      name: "Case4",
      data: new Uint8Array([
        0xf1, 0xf1, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
        0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
        0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3,
        0xf4, 0xaa, 0xaa, 0xaa, 0xf5, 0xaa, 0xaa, 0xaa, 0xf5, 0xf5, 0xf5, 0xf5,
        0xaa, 0xaa, 0xaa, 0xaa, 0x04, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xc4, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x04, 0xc4, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0x01, 0xaa, 0xaa, 0xaa, 0x01, 0xd4, 0xaa, 0xaa,
      ]),
      state: {
        bytemuck_struct_c: bytemuckStructC,
        bytemuck_enum_c: { Case4: [0xc4] },
        bytemuck_enum_u8: { Case4: [0xc4] },
        bytemuck_discriminant_c: "CaseB",
        bytemuck_discriminant_u8: "CaseB",
        bytemuck_never: null,
        bytemuck_field: 0xd4,
      },
    },
    {
      name: "Case5",
      data: new Uint8Array([
        0xf1, 0xf1, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
        0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2,
        0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3,
        0xf4, 0xaa, 0xaa, 0xaa, 0xf5, 0xaa, 0xaa, 0xaa, 0xf5, 0xf5, 0xf5, 0xf5,
        0xaa, 0xaa, 0xaa, 0xaa, 0x05, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xc5, 0xc5, 0xc5, 0xc5, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0x05, 0xaa, 0xaa, 0xaa,
        0xc5, 0xc5, 0xc5, 0xc5, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
        0x02, 0xaa, 0xaa, 0xaa, 0x02, 0xd5, 0xaa, 0xaa,
      ]),
      state: {
        bytemuck_struct_c: bytemuckStructC,
        bytemuck_enum_c: { Case5: [0xc5c5c5c5] },
        bytemuck_enum_u8: { Case5: [0xc5c5c5c5] },
        bytemuck_discriminant_c: "CaseC",
        bytemuck_discriminant_u8: "CaseC",
        bytemuck_never: null,
        bytemuck_field: 0xd5,
      },
    },
  ];
  // Actually assert the correctness of the results
  for (const testCase of cases) {
    const computedData = idlAccountEncode(accountIdl, testCase.state);
    // dumpData(testCase.name + ":computedData", computedData);
    // dumpData(testCase.name + ":expectedData", testCase.data);
    expect(idlAccountDecode(accountIdl, testCase.data)).toStrictEqual(
      testCase.state,
    );
    expect(idlAccountDecode(accountIdl, computedData)).toStrictEqual(
      testCase.state,
    );
  }
});

/*
function dumpData(title: string, data: Uint8Array) {
  const lines = [];
  const lineCount = (data.length + 1) / 16;
  for (let line = 0; line < lineCount; line++) {
    const words = [];
    words.push("@" + (line * 16).toString().padStart(6, "0"));
    for (let word = 0; word < 4; word++) {
      const bytes = [];
      for (let byte = 0; byte < 4; byte++) {
        const offset = line * 16 + word * 4 + byte;
        if (offset < data.length) {
          const value = data[offset]!;
          bytes.push(value.toString(16).padStart(2, "0").toUpperCase());
        } else {
          bytes.push("  ");
        }
      }
      words.push(bytes.join(" "));
    }
    lines.push(words.join("  "));
  }
  console.log(title, "\n" + lines.join("\n"));
}
*/
